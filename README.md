# NYU CS-UY 4613 (Artificial Intelligence) Project
Minimax with Alpha-Beta Pruning in Checkers

## Build
You must have `go` installed as well as `dep`.

Built with the following:

```shell
% go version
go version go1.10 linux/amd64

% dep version
dep:
 version     : v0.4.1
 build date  : 2018-01-24
 git hash    : 37d9ea0a
 go version  : go1.9.1
 go compiler : gc
 platform    : linux/amd64
```

Refer to the following for installation:

- https://golang.org/doc/install
- https://github.com/golang/dep

You must also get a tool before continuing:

```
go get -v -u github.com/asticode/go-astilectron-bundler/...
```
This should drop in an executable at `$GOPATH/bin` called `astilectron-bundler`.

Now you can build the actual application.

1. Move the directory to your `$GOPATH`

```shell
% mkdir -p $GOPATH/src/
# assuming directory is called project
% mv project $GOPATH/src/
```

2. Move to the directory

```shell
cd $GOPATH/src/project
```

3. Pull down the dependency

```shell
% dep ensure
```

4. Run the bundler (this is required to build at all as it will generate embedded binary data as well as some missing methods)
   - This step only has to be run once unless the data that gets embedded changes (which it won't since you will be just building and not modifying)

```shell
% $GOPATH/bin/astilectron-bundler -v && chmod +x 
```

5. [OPTIONAL] Build it - this should place an executable in your directory with the same name as the directory

```shell
% go build
```

4. Run it
   - Linux: `build/linux-amd64/Checkers`
   - MacOS: `build/darwin-amd64/Checkers`
   - Windows: `build/windows-amd64/Checkers`

```shell
# again assuming the directory was called project and that you're going to run it on the current commputer
% ./project
# OR for bundled packages for different operating systems (tested only on Linux)
% ./build/linux-amd64/Checkers 
```

##Running

As stated above, there are several different outputs you can use. First and foremost is the output generated by `go build`. This will place an executable in the directory with name corresponding to the directory's name e.g. if you are in `project` and build it then it will result in an executable called `project` inside the `project` directory. This will be specific to the machine you build it on.

You can also use the builds provided by the bundler, which bundles together a binary for Linux, Windows, and MacOS. This will be in `build/$OS-amd64/Checkers` where `$OS` is one of `linux`, `darwin`, or `windows`. Be sure to use the proper executable for the proper operating system.

It's recommended that you run the bundler first and then just use the output of `go build`.

### Flags

The executable will show the different options available.

```shell
% ./project --help
Usage of ./project:
  -debug
    	Debug mode
  -depth int
    	Depth of minimax (default 16)
  -difficulty int
    	Difficulty indicated from 1 - 3 with 3 being the hardest (default 3)
  -first uint
    	Who should go first, 2 for human and 1 for ai (default 2)
  -gui
    	Initialize with a GUI
  -logger-app-name string
    	the logger's app name
  -v	if true, then log level is debug

```

## Design

I decided to split the work up into two pieces - a checkers engine that has all the necessary structures and methods to run a game as well as the actual driver program with the AI.

### go_checkers 

This is located at: https://github.com/jwoos/go_checkers

The main structure of this package is `StateByte` which keeps track of the game state as a 2D matrix of `byte`s which represent pieces. The other key structure is `Rule` which defines the ruleset for the game - I made it this way as I wanted a reusable checkers engine but the assignment deviated from the standard rules of checkers. The other files were implemented to be used for a full game of checkers: `StateByte` and `State` are almost identical except the former uses a 2D matrix of `byte`s for the game board while the latter uses `Piece`s.

`StateByte` has various methods associated with it that help drive a game. For instance it can get all the possible moves for a current side by `PossibleMovesAll`. It can also return only the possible moves for a given piece with `PossibleMoves`. It has analogous functions to return only capture moves in the forms of `PossibleCaptureMoves` and `PossibleCaptureMovesAll`.

`StateByte` is also capable of doing error checks and checking if the game has ended. This basically takes care of all the minute details of actually playing a chess game from moving a piece to validating that a move is correct. It also implements the `Stringer` interface for pretty printing out the game state.

### Driver

This is the driver of the actual program. At its core, it takes the checkers package and makes use of it to run an actual game. It's further divided into two sections: GUI and CLI. The main package just parses some flags and decides to either run the GUI or CLI version.

####CLI

The CLI game is just a loop going between human and AI. Before each move, it checks if either the game has ended or the player has no moves left.

#### GUI

The GUI version is actually an electron application using astilectron which aims to simplify things a bit. Essentially the electron GUI is the client and the Go application is the server. It then falls to passing messages between the two via an internal HTTP call. The GUI does no calculations of its own meaning that everything is offloaded to the server since everything was being done there anyways. After each move, it's checked whether the game has ended or whether the player has no moves left.

The JavaScript code is just simple rendering code, to take the state of the game and just display it.